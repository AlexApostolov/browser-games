<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Monster Smash</title>
</head>

<body>
  <canvas width="128" height="128"></canvas>
  <script>
    var monster = {
      // Use a single png to animate the monster.
      IMAGE: '../images/monsterTileSheet.png',
      SIZE: 128,
      COLUMNS: 3,

      // The number of animation frames starting from 0 index & the starting frame
      numberOfFrames: 5,
      currentFrame: 0,

      // Properties of the animation cell's x & y positions on the spritesheet. Init at 0.
      sourceX: 0,
      sourceY: 0,

      // A variable to control the direction of the loop. When the object first loads it will run forwards, i.e. monster jumps.
      forward: true,

      // States: when only the hole is shown, the monster is hiding, otherwise the monster is jumping.
      HIDING: 0,
      JUMPING: 1,
      // The initial state is set to HIDING so that the monster won't be visible when the animation first loads.
      state: this.HIDING,

      // A property to store the random time. This value will be updated every 300ms.
      waitTime: undefined,

      // A method to find a random animation time. It will be called when the spritesheet has loaded.
      findWaitTime: function () {
        this.waitTime = Math.ceil(Math.random() * 60);
      },

      // Animation method for monster
      updateAnimation: function () {
        // Figure out the monster's state
        if (this.waitTime > 0 || this.waitTime === undefined) {
          this.state = this.HIDING;
        } else {
          this.state = this.JUMPING;
        }

        // Switch the monster's action based on its state
        switch (this.state) {
          case this.HIDING:
            this.currentFrame = 0;
            this.waitTime--;
            break;
          // When waitTime reaches 0, the monster's state switches to JUMPING.
          case this.JUMPING:
            // If the last frame has been reached, reverse the loop direction so that the monster falls back down.
            if (this.currentFrame === this.numberOfFrames) {
              this.forward = false;
            }
            // If the first frame has been reached, set loop to run forwards again, i.e. monster to jump.
            if (this.currentFrame === 0 && this.forward === false) {
              // Set forward to true, find a new waitTime, & set state to HIDING before breaking.
              this.forward = true;
              this.findWaitTime();
              this.state = this.HIDING;
              break;
            }

            // Add 1 to currentFrame if forward is true, or subtract 1 if it's false
            if (this.forward) {
              this.currentFrame++;
            } else {
              this.currentFrame--;
            }
        }
        // Use frame's correct column & row of the spritesheet to display.
        // As long as the COLUMN is up to date, these formulas will always work.

        // sourceX represents the column that the frame is on.
        // Using the modulus operator we cycle through the X positions of the spritesheet's 3 columns,
        // whose numbers will exactly match the X positions of the frame we want to display.
        this.sourceX = Math.floor(this.currentFrame % this.COLUMNS) * this.SIZE;
        this.sourceY = Math.floor(this.currentFrame / this.COLUMNS) * this.SIZE;
      }
    };
    // Get a reference to the canvas
    var canvas = document.querySelector('canvas');
    // Get a reference to the canvas's drawing surface
    var drawingSurface = canvas.getContext('2d');
    // Hold the animation spritesheet in a created invisible <img>. You can now load and access any image using this variable.
    var image = new Image();
    // Add a listener to the image to call the render function when the image has finished loaded.
    // This is needed to solve a technical issue. The image won't load instantly; 
    // it takes a few milliseconds for the program to load it, and we don't want the rest of the program to continue to run without a visible image.
    image.addEventListener('load', loadHandler, false);
    // Assign the image's src property to the image you want to load. This image will be overwritten by monsterStates.png
    image.src = monster.IMAGE;

    function loadHandler() {
      // Find a random wait time.
      monster.findWaitTime();
      // Start the animation
      updateAnimation();
    }

    function updateAnimation() {
      // Set a timer to call itself every 300 milliseconds, i.e. recursion.
      setTimeout(updateAnimation, 300);
      // Update the monster's animation frames
      monster.updateAnimation();
      // Render the animation
      render();
    }

    function render() {
      // It's always important to clear the canvas first when you're doing animation so that any images from the previous frames aren't displayed.
      // Clear the entire canvas of any previous frames with the clearRect method.
      drawingSurface.clearRect(0, 0, canvas.width, canvas.height);

      // Draw the monster's current animation frame.
      drawingSurface.drawImage(
        image,
        monster.sourceX, monster.sourceY, monster.SIZE, monster.SIZE,
        0, 0, monster.SIZE, monster.SIZE
      );
    };
  </script>
</body>

</html>